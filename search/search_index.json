{
    "docs": [
        {
            "location": "/", 
            "text": "Forge\n\n\n \n\n\nForge is a Swift iOS framework for interacting with HTTP services.\n\n\nLinks\n\n\nQuick Start\n\n\nAPI Reference\n\n\nInstallation\n\n\nGit submodule\n\n\nForge can be added as a dependency of a project as a git submodule.\n\ngit submodule add git@github.com:stablekernel/Forge.git\n\n\nThis leaves the option of using the source files directly or embedding as a framework.\n\n\n\n\nSource files directly\n\n\nCreate a group for Forge\n\n\nDrag the source files from Forge/Forge into the group\n\n\n\n\nstablekernel/striker\n has a script for creating a project with Forge source files already included.\n\n\n\n\n\n\nEmbedded framework\n\n\n\n\nDrag Forge.xcodeproj into your project\n\n\nAdd Forge.framework to your project as an embedded binary\n\n\n\n\nUsing an embedded framework gets a little tricky when the parent project uses any configurations other than \nDebug\n and \nRelease\n. If your project needs more configurations, install the source files directly.", 
            "title": "Home"
        }, 
        {
            "location": "/#forge", 
            "text": "Forge is a Swift iOS framework for interacting with HTTP services.", 
            "title": "Forge"
        }, 
        {
            "location": "/#links", 
            "text": "Quick Start  API Reference", 
            "title": "Links"
        }, 
        {
            "location": "/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/#git-submodule", 
            "text": "Forge can be added as a dependency of a project as a git submodule. git submodule add git@github.com:stablekernel/Forge.git  This leaves the option of using the source files directly or embedding as a framework.   Source files directly  Create a group for Forge  Drag the source files from Forge/Forge into the group   stablekernel/striker  has a script for creating a project with Forge source files already included.    Embedded framework   Drag Forge.xcodeproj into your project  Add Forge.framework to your project as an embedded binary   Using an embedded framework gets a little tricky when the parent project uses any configurations other than  Debug  and  Release . If your project needs more configurations, install the source files directly.", 
            "title": "Git submodule"
        }, 
        {
            "location": "/quickstart/", 
            "text": "Quickstart\n\n\nIn Forge, an HTTP server is represented by a \nGateway\n.\n\n\nlet\n \ngateway\n \n=\n \nGateway\n(\nbaseURL\n:\n \nmyURL\n)\n\n\n\n\n\n\nGateway\ns are used to make and execute \nRequest\ns, that return a \nPromise\n for your model objects.\n\n\nlet\n \nrequest\n \n=\n \ngateway\n.\nrequest\n(\nusers\n,\n \nuserID\n)\n\n\nrequest\n\n  \n.\nexecute\n()\n\n  \n.\ndecode\n(\nas\n:\n \nUser\n.\nself\n)\n\n\n\n\n\n\nGateway\ns \ncan be customized\n to modify all requests made through them.\n\n\nRequest\ns include conveniences for working with \nHTTPMethod\ns, \nHTTPHeaders\n and \nHTTPBody\ns, and return \nResponse\ns, that can be modified or decoded.\nMore on \nRequest\ns \nhere\n.\n\n\nlet\n \nrequest\n \n=\n \ngateway\n.\nrequest\n(\nusers\n)\n\n\nrequest\n.\nheaders\n.\nadd\n(.\ncontentType\n,\n \napplication/json\n)\n\n\nrequest\n.\nmethod\n \n=\n \n.\npost\n\n\ntry\n \nrequest\n.\nbody\n.\nencode\n(\nmyNewUser\n)\n\n\nrequest\n\n  \n.\nexecute\n()\n\n  \n.\nthen\n(\nMyResponseMiddleware\n())\n\n  \n.\ndecode\n(\nas\n:\n \nUser\n.\nself\n)\n\n\n\n\n\n\nAny model objects conforming to the \nCodable\n protocols can be used with \nRequest\n and \nResponse\n, although there are also \nother Codable conveniences built in\n.", 
            "title": "Quickstart"
        }, 
        {
            "location": "/quickstart/#quickstart", 
            "text": "In Forge, an HTTP server is represented by a  Gateway .  let   gateway   =   Gateway ( baseURL :   myURL )   Gateway s are used to make and execute  Request s, that return a  Promise  for your model objects.  let   request   =   gateway . request ( users ,   userID )  request \n   . execute () \n   . decode ( as :   User . self )   Gateway s  can be customized  to modify all requests made through them.  Request s include conveniences for working with  HTTPMethod s,  HTTPHeaders  and  HTTPBody s, and return  Response s, that can be modified or decoded.\nMore on  Request s  here .  let   request   =   gateway . request ( users )  request . headers . add (. contentType ,   application/json )  request . method   =   . post  try   request . body . encode ( myNewUser )  request \n   . execute () \n   . then ( MyResponseMiddleware ()) \n   . decode ( as :   User . self )   Any model objects conforming to the  Codable  protocols can be used with  Request  and  Response , although there are also  other Codable conveniences built in .", 
            "title": "Quickstart"
        }, 
        {
            "location": "/gateway/", 
            "text": "Customizing a Gateway", 
            "title": "Customizing a Gateway"
        }, 
        {
            "location": "/gateway/#customizing-a-gateway", 
            "text": "", 
            "title": "Customizing a Gateway"
        }, 
        {
            "location": "/request/", 
            "text": "Making Requests\n\n\nRequest\n is a protocol that includes \nURLComponents\n, an \nHTTPMethod\n, \nHTTPHeaders\n, and an \nHTTPBody\n.\n\n\nCreating Requests\n\n\nThe simplest is an \nHTTPRequest\n which is a struct with only these properties.\n\n\nAn \nHTTPRequest\n can be created with as little as a \nURL\n which will default to a \nget\n \nHTTPMethod\n, empty \nHTTPHeaders\n and an empty \nHTTPBody\n\n\nvar\n \nrequest\n \n=\n \nHTTPRequest\n(\nURL\n(\nstring\n:\n \nwww.stablekernel.io\n)\n!\n)\n\n\n\n\n\n\nGateway\ns make \nGatewayRequest\ns, which are generic to the type of gateway:\n\n\nlet\n \ngateway\n \n=\n \nGateway\n(\nbaseURL\n:\n \nURL\n(\nstring\n:\n \nwww.stablekernel.io\n)\n!\n)\n\n\nlet\n \nrequest\n \n=\n \ngateway\n.\nmakeRequest\n(\nusers\n)\n \n// GatewayRequest\nGateway\n\n\n\n\n\n\nlet\n \noauthGateway\n \n=\n \nOAuthGateway\n(\nbaseURL\n:\n \nURL\n(\nstring\n:\n \nwww.stablekernel.io\n)\n!\n)\n\n\nlet\n \nrequest\n \n=\n \noauthGateway\n.\nmakeRequest\n(\nusers\n)\n \n// GatewayRequest\nOAuthGateway\n\n\n\n\n\n\nIt is also possible to define your own type that conforms to \nRequest\n.\n\n\nModifying Requests\n\n\nHTTPMethod\n\n\nHTTPMethod\n includes the common defined types like \n.get\n or \n.post\n, but it can also accept custom values\n\n\nrequest\n.\nmethod\n \n=\n \n.\npost\n\n\n\n\n\n\nrequest\n.\nmethod\n \n=\n \nOTHER\n\n\n\n\n\n\nHTTPHeaders\n\n\nAny string value can be added to a \nRequest\n's \nHTTPHeaders\n, and there are also conveniences for common values\n\n\nrequest\n.\nheaders\n.\nadd\n(\nx-my-custom-header\n,\n \nvalue\n:\n \nSome value\n)\n\n\nrequest\n.\nheaders\n.\nadd\n(.\naccept\n,\n \nvalue\n:\n \napplication/json\n)\n\n\nrequest\n.\nheaders\n.\nauthorization\n \n=\n \nBasic asdfasdfasdfdsafas==\n\n\n\n\n\n\nHTTPBody\n\n\nAn \nHTTPBody\n can be used to encode or decode model objects. More information on this \nhere\n.\n\n\nExecuting Requests\n\n\nAny \nRequest\n can be executed through an \nHTTPClient\n, which will return a \nPromise\nResponse\n.\n\n\nlet\n \nclient\n:\n \nHTTPClient\n \n=\n \nURLSession\n(\nconfiguration\n:\n \n.\ndefault\n)\n\n\nclient\n\n  \n.\nexecute\n(\nrequest\n)\n\n  \n.\nthen\n(\nMyResponseMiddleware\n())\n\n  \n.\ndecode\n(\nas\n:\n \nUser\n.\nself\n)\n \n// Returns Promise\nUser\n\n\n\n\n\n\nGatewayRequest\ns have a convenience function \nexecute\n, which executes them through their \ngateway\n\n\nlet\n \ngateway\n \n=\n \nGateway\n(\nbaseURL\n:\n \nURL\n(\nstring\n:\n \nwww.stablekernel.io\n)\n!\n)\n\n\nlet\n \nrequest\n \n=\n \ngateway\n.\nmakeRequest\n(\nusers\n)\n\n\nrequest\n\n  \n.\nexecute\n()\n\n  \n.\nthen\n(\nMyResponseMiddleware\n())\n\n  \n.\ndecode\n(\nas\n:\n \nUser\n.\nself\n)\n \n// Returns Promise\nUser\n\n\n\n\n\n\nMore on response middleware \nhere\n and decoding responses \nhere", 
            "title": "Making Requests"
        }, 
        {
            "location": "/request/#making-requests", 
            "text": "Request  is a protocol that includes  URLComponents , an  HTTPMethod ,  HTTPHeaders , and an  HTTPBody .", 
            "title": "Making Requests"
        }, 
        {
            "location": "/request/#creating-requests", 
            "text": "The simplest is an  HTTPRequest  which is a struct with only these properties.  An  HTTPRequest  can be created with as little as a  URL  which will default to a  get   HTTPMethod , empty  HTTPHeaders  and an empty  HTTPBody  var   request   =   HTTPRequest ( URL ( string :   www.stablekernel.io ) ! )   Gateway s make  GatewayRequest s, which are generic to the type of gateway:  let   gateway   =   Gateway ( baseURL :   URL ( string :   www.stablekernel.io ) ! )  let   request   =   gateway . makeRequest ( users )   // GatewayRequest Gateway   let   oauthGateway   =   OAuthGateway ( baseURL :   URL ( string :   www.stablekernel.io ) ! )  let   request   =   oauthGateway . makeRequest ( users )   // GatewayRequest OAuthGateway   It is also possible to define your own type that conforms to  Request .", 
            "title": "Creating Requests"
        }, 
        {
            "location": "/request/#modifying-requests", 
            "text": "", 
            "title": "Modifying Requests"
        }, 
        {
            "location": "/request/#httpmethod", 
            "text": "HTTPMethod  includes the common defined types like  .get  or  .post , but it can also accept custom values  request . method   =   . post   request . method   =   OTHER", 
            "title": "HTTPMethod"
        }, 
        {
            "location": "/request/#httpheaders", 
            "text": "Any string value can be added to a  Request 's  HTTPHeaders , and there are also conveniences for common values  request . headers . add ( x-my-custom-header ,   value :   Some value )  request . headers . add (. accept ,   value :   application/json )  request . headers . authorization   =   Basic asdfasdfasdfdsafas==", 
            "title": "HTTPHeaders"
        }, 
        {
            "location": "/request/#httpbody", 
            "text": "An  HTTPBody  can be used to encode or decode model objects. More information on this  here .", 
            "title": "HTTPBody"
        }, 
        {
            "location": "/request/#executing-requests", 
            "text": "Any  Request  can be executed through an  HTTPClient , which will return a  Promise Response .  let   client :   HTTPClient   =   URLSession ( configuration :   . default )  client \n   . execute ( request ) \n   . then ( MyResponseMiddleware ()) \n   . decode ( as :   User . self )   // Returns Promise User   GatewayRequest s have a convenience function  execute , which executes them through their  gateway  let   gateway   =   Gateway ( baseURL :   URL ( string :   www.stablekernel.io ) ! )  let   request   =   gateway . makeRequest ( users )  request \n   . execute () \n   . then ( MyResponseMiddleware ()) \n   . decode ( as :   User . self )   // Returns Promise User   More on response middleware  here  and decoding responses  here", 
            "title": "Executing Requests"
        }, 
        {
            "location": "/model/", 
            "text": "Defining and Decoding Model Objects\n\n\nCodable\n\n\nAny type that conforms to \nEncodable\n can be encoded to an \nHTTPBody\n in a \nRequest\n or \nResponse\n.\n\n\nstruct\n \nMyType\n:\n \nCodable\n \n{\n\n    \nlet\n \nid\n:\n \nInt\n\n    \nvar\n \nname\n:\n \nString\n\n\n}\n\n\n\nlet\n \nmyObject\n \n=\n \nMyType\n(\nid\n:\n \n1\n,\n \nname\n:\n \nBob\n)\n\n\n\ntry\n \nsomeRequest\n.\nbody\n.\nencode\n(\nmyObject\n)\n\n\n\n\n\n\nLikewise, any class that is \nDecodable\n can be decoded from an \nHTTPBody\n.\n\n\nlet\n \nvalue\n \n=\n \ntry\n \nsomeRequest\n.\nbody\n.\ndecode\n(\nas\n:\n \nMyType\n.\nself\n)\n\n\n\n\n\n\nIn addtion to these \nCodable\n protocols, Forge also has some extensions that can be used:\n\n\nDecoderUpdatable\n\n\nTo create a type that can be updated from a \nDecoder\n, make it conform to \nDecoderUpdatable\n:\n\n\nprotocol\n \nDecoderUpdatable\n \n{\n\n    \nmutating\n \nfunc\n \nupdate\n(\nfrom\n \ndecoder\n:\n \nDecoder\n)\n \nthrows\n\n\n}\n\n\n\n\n\n\nstruct\n \nMyUpdatableType\n:\n \nDecoderUpdatable\n \n{\n\n    \nlet\n \nid\n:\n \nInt\n\n    \nvar\n \nname\n:\n \nString\n\n\n    \nenum\n \nKey\n:\n \nString\n,\n \nCodingKey\n \n{\n\n        \ncase\n \nid\n\n        \ncase\n \nname\n\n    \n}\n\n\n    \nmutating\n \nfunc\n \nupdate\n(\nfrom\n \ndecoder\n:\n \nDecoder\n)\n \nthrows\n \n{\n\n        \nlet\n \ncontainer\n \n=\n \ntry\n \ndecoder\n.\ncontainer\n(\nkeyedBy\n:\n \nKey\n.\nself\n)\n\n        \nname\n \n=\n \ntry\n \ncontainer\n.\ndecode\n(\nString\n.\nself\n,\n \nforKey\n:\n \n.\nname\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDecoderUpdatable\n types can be updated from an \nHTTPBody\n:\n\n\nlet\n \nmyObject\n \n=\n \nMyUpdatableType\n(\nid\n:\n \n1\n,\n \nname\n:\n \nold name\n)\n\n\n\nlet\n \nupdated\n \n=\n \ntry\n \nsomeResponse\n.\nbody\n.\nupdate\n(\nmyObject\n)\n\n\n\n\n\n\nDecoderUpdatable\n types can also be updated from containers:\n\n\nclass\n \nParent\n:\n \nDecoderUpdatable\n \n{\n\n    \nlet\n \nid\n:\n \nInt\n\n    \nvar\n \nname\n:\n \nString\n?\n\n    \nvar\n \nchild\n:\n \nMyUpdatableType\n\n\n    \ninit\n(\nid\n:\n \nInt\n,\n \nname\n:\n \nString\n?,\n \nchild\n:\n \nMyUpdatableType\n)\n \n{\n\n        \nself\n.\nid\n \n=\n \nid\n\n        \nself\n.\nname\n \n=\n \nname\n\n        \nself\n.\nchild\n \n=\n \nchild\n\n    \n}\n\n\n    \nenum\n \nKey\n:\n \nString\n,\n \nCodingKey\n \n{\n\n        \ncase\n \nid\n\n        \ncase\n \nname\n\n        \ncase\n \nchild\n\n    \n}\n\n\n    \nfunc\n \nupdate\n(\nfrom\n \ndecoder\n:\n \nDecoder\n)\n \nthrows\n \n{\n\n        \nlet\n \ncontainer\n \n=\n \ntry\n \ndecoder\n.\ncontainer\n(\nkeyedBy\n:\n \nKey\n.\nself\n)\n\n        \nname\n \n=\n \ntry\n \ncontainer\n.\ndecode\n(\nString\n.\nself\n,\n \nforKey\n:\n \n.\nname\n)\n\n        \nchild\n \n=\n \ntry\n \ncontainer\n.\nupdate\n(\nchild\n,\n \nforKey\n:\n \n.\nchild\n)\n\n    \n}\n\n\n}\n\n\n\nlet\n \nparent\n \n=\n \nParent\n(\nid\n:\n \n2\n,\n \nname\n:\n \nParent Old Name\n,\n \nchild\n:\n \nmyObject\n)\n\n\n\n// parent is a reference type and does not need reassignment after the update\n\n\ntry\n \nsomeResponse\n.\nbody\n.\nupdate\n(\nparent\n)\n\n\n\n\n\n\nDecodingFactory\n\n\nThere are some classes that just can't be made to conform to \nDecodable\n for these, you can use a \nDecodingFactory\n to create an object from a \nDecoder\n:\n\n\nprotocol\n \nDecodingFactory\n \n{\n\n    \nassociatedtype\n \nModel\n\n    \nfunc\n \ncreate\n(\nfrom\n \ndecoder\n:\n \nDecoder\n)\n \nthrows\n \n-\n \nModel\n\n\n}\n\n\n\n\n\n\nstruct\n \nCLLocationFactory\n:\n \nDecodingFactory\n \n{\n\n    \nenum\n \nKey\n:\n \nString\n,\n \nCodingKey\n \n{\n\n        \ncase\n \nlatitude\n\n        \ncase\n \nlongitude\n\n    \n}\n\n\n    \nfunc\n \ncreate\n(\nfrom\n \ndecoder\n:\n \nDecoder\n)\n \nthrows\n \n-\n \nCLLocation\n \n{\n\n        \nlet\n \ncontainer\n \n=\n \ntry\n \ndecoder\n.\ncontainer\n(\nkeyedBy\n:\n \nKey\n.\nself\n)\n\n        \nlet\n \nlatitude\n \n=\n \ntry\n \ncontainer\n.\ndecode\n(\nDouble\n.\nself\n,\n \nforKey\n:\n \n.\nlatitude\n)\n\n        \nlet\n \nlongitude\n \n=\n \ntry\n \ncontainer\n.\ndecode\n(\nDouble\n.\nself\n,\n \nforKey\n:\n \n.\nlongitude\n)\n\n        \nreturn\n \nCLLocation\n(\nlatitude\n:\n \nlatitude\n,\n \nlongitude\n:\n \nlongitude\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDecodingFactory\n can be used with \nHTTPBody\ns instead of a \nDecodable\n type:\n\n\nlet\n \nlocation\n \n=\n \nsomeResponse\n.\nbody\n.\ndecode\n(\nusing\n:\n \nCLLocationFactory\n())\n\n\n\n\n\n\nManagedDecodable\n\n\nCoreData objects are among those that can't be made \nDecodable\n. For these there is another protocol: \nManagedDecodable\n\n\nprotocol\n \nManagedDecodable\n:\n \nDecoderUpdatable\n \n{\n\n    \nstatic\n \nvar\n \nentityName\n:\n \nString\n \n{\n \nget\n \n}\n\n    \nstatic\n \nvar\n \nmatchKeys\n:\n \n[\nMatchKey\n]?\n \n{\n \nget\n \n}\n\n    \nstatic\n \nfunc\n \ncreateOrUpdate\n(\nin\n \ncontext\n:\n \nNSManagedObjectContext\n,\n \nfrom\n \ndecoder\n:\n \nDecoder\n)\n \nthrows\n \n-\n \nSelf\n\n\n}\n\n\n\n\n\n\nThe \ncreateOrUpdate\n function has a default implementation for all \nNSManagedObject\ns which creates a new instance of the object in the \nNSManagedObjectContext\n.\n\n\nIf you provide a \nmatchKeys\n property, the default \ncreateOrUpdate\n implementation will update a matching object if it exists, and create a new one if it cannot find a match.\n\n\nclass\n \nUser\n:\n \nNSManagedObject\n,\n \nManagedDecodable\n \n{\n\n    \nstatic\n \nvar\n \nentityName\n:\n \nString\n \n=\n \nUser\n\n    \nstatic\n \nvar\n \nmatchKeys\n:\n \n[\nMatchKey\n]?\n \n=\n \n[\n\n        \n.\nkey\n(\nKey\n.\nid\n)\n\n    \n]\n\n\n    \n@NSManaged\n \nvar\n \nid\n:\n \nInt\n\n    \n@NSManaged\n \nvar\n \nname\n:\n \nString\n\n\n    \nenum\n \nKey\n:\n \nString\n,\n \nCodingKey\n \n{\n\n        \ncase\n \nid\n\n        \ncase\n \nname\n\n    \n}\n\n\n    \nfunc\n \nupdate\n(\nfrom\n \ndecoder\n:\n \nDecoder\n)\n \nthrows\n \n{\n\n        \nlet\n \ncontainer\n \n=\n \ntry\n \ndecoder\n.\ncontainer\n(\nkeyedBy\n:\n \nKey\n.\nself\n)\n\n        \nid\n \n=\n \ntry\n \ncontainer\n.\ndecode\n(\nInt\n.\nself\n,\n \nforKey\n:\n \n.\nid\n)\n\n        \nname\n \n=\n \ntry\n \ncontainer\n.\ndecode\n(\nString\n.\nself\n,\n \nforKey\n:\n \n.\nname\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nManagedDecodable\n classes can be decoded using a \nManagedDecodingFactory\n:\n\n\nlet\n \nfactory\n \n=\n \nManagedDecodingFactory\nUser\n(\ncontext\n:\n \nmyContext\n)\n\n\nlet\n \nuser\n \n=\n \ntry\n \nsomeResponse\n.\nbody\n.\ndecode\n(\nusing\n:\n \nfactory\n)\n\n\n\n\n\n\nCodingFormats\n\n\nForge has protocols for high-level decoders and encoders, like \nJSONDecoder\n, \nPropertyListDecoder\n, \nJSONEncoder\n and \nPropertyListEncoder\n.\n\n\nThese are \nDecodingFormat\n:\n\n\npublic\n \nprotocol\n \nDecodingFormat\n \n{\n\n    \nfunc\n \ndecoder\n(\nfor\n \ndata\n:\n \nData\n)\n \n-\n \nDecoder\n\n\n}\n\n\n\n\n\n\nand \nEncodingFormat\n:\n\n\npublic\n \nprotocol\n \nEncodingFormat\n \n{\n\n    \nfunc\n \nencode\nT\n:\n \nEncodable\n(\n_\n \nvalue\n:\n \nT\n)\n \nthrows\n \n-\n \nData\n\n\n}\n\n\n\n\n\n\nHTTPBody\ns have \ndecodingFormat\n and \nencodingFormat\n properties that correspond to these protocols.\n\n\nThe default values for these are \nJSONDecoder()\n and \nJSONEncoder()\n, but requests executed through a \nGateway\n may have these changed by the gateway.\n\n\nThese properties can be changed\n\n\nsomeRequest\n.\nbody\n.\nencodingFormat\n \n=\n \nPropertyListEncoder\n()\n\n\nlet\n \nvalue\n \n=\n \ntry\n \nsomeRequest\n.\nbody\n.\ndecode\n(\nas\n:\n \nMyType\n.\nself\n)\n\n\n\n\n\n\nor you can pass a format explicitly to \nHTTPBody\n's \ndecode\n and \nencode\n functions:\n\n\ntry\n \nsomeRequest\n.\nbody\n.\nencode\n(\nmyObject\n,\n \nwith\n:\n \nPropertyListEncoder\n())\n\n\n\nlet\n \nvalue\n \n=\n \ntry\n \nsomeRequest\n.\nbody\n.\ndecode\n(\nas\n:\n \nMyType\n.\nself\n,\n \nwith\n:\n \nPropertyListDecoder\n())\n\n\n\n\n\n\nDecoding Promises\n\n\nForge has conveniences for Decoding \nResponse\n or \nRequest\n \nPromise\ns that match the methods on \nHTTPBody\n:\n\n\ngateway\n\n  \n.\nrequest\n(\nthings\n,\n \nid\n)\n\n  \n.\nexecute\n()\n\n  \n.\ndecode\n(\nas\n:\n \nMyType\n.\nself\n)\n \n// Returns Promise\nMyType\n\n\n\ngateway\n\n  \n.\nrequest\n(\nthings\n,\n \nid\n)\n\n  \n.\nexecute\n()\n\n  \n.\ndecode\n(\nas\n:\n \nMyType\n.\nself\n,\n \nwith\n:\n \nPropertyListDecoder\n())\n \n// Returns Promise\nMyType\n\n\n\n\ngateway\n\n  \n.\nrequest\n(\nusers\n,\n \nuserID\n)\n\n  \n.\nexecute\n()\n\n  \n.\ndecode\n(\nusing\n:\n \nManagedDecodingFactory\nUser\n(\ncontext\n:\n \nmyContext\n))\n \n// Returns Promise\nUser\n\n\n\n\n\n\nRequests executed through a \nManagedGateway\n also have conveniences for \nManagedDecodable\n objects, instead of needing a \nManagedDecodingFactory\n:\n\n\nmanagedGateway\n\n  \n.\nrequest\n(\nusers\n,\n \nuserID\n)\n\n  \n.\nexecute\n()\n\n  \n.\ndecode\n(\nmanaged\n:\n \nUser\n.\nself\n)\n \n// Returns Promise\nUser", 
            "title": "Defining a Model"
        }, 
        {
            "location": "/model/#defining-and-decoding-model-objects", 
            "text": "", 
            "title": "Defining and Decoding Model Objects"
        }, 
        {
            "location": "/model/#codable", 
            "text": "Any type that conforms to  Encodable  can be encoded to an  HTTPBody  in a  Request  or  Response .  struct   MyType :   Codable   { \n     let   id :   Int \n     var   name :   String  }  let   myObject   =   MyType ( id :   1 ,   name :   Bob )  try   someRequest . body . encode ( myObject )   Likewise, any class that is  Decodable  can be decoded from an  HTTPBody .  let   value   =   try   someRequest . body . decode ( as :   MyType . self )   In addtion to these  Codable  protocols, Forge also has some extensions that can be used:", 
            "title": "Codable"
        }, 
        {
            "location": "/model/#decoderupdatable", 
            "text": "To create a type that can be updated from a  Decoder , make it conform to  DecoderUpdatable :  protocol   DecoderUpdatable   { \n     mutating   func   update ( from   decoder :   Decoder )   throws  }   struct   MyUpdatableType :   DecoderUpdatable   { \n     let   id :   Int \n     var   name :   String \n\n     enum   Key :   String ,   CodingKey   { \n         case   id \n         case   name \n     } \n\n     mutating   func   update ( from   decoder :   Decoder )   throws   { \n         let   container   =   try   decoder . container ( keyedBy :   Key . self ) \n         name   =   try   container . decode ( String . self ,   forKey :   . name ) \n     }  }   DecoderUpdatable  types can be updated from an  HTTPBody :  let   myObject   =   MyUpdatableType ( id :   1 ,   name :   old name )  let   updated   =   try   someResponse . body . update ( myObject )   DecoderUpdatable  types can also be updated from containers:  class   Parent :   DecoderUpdatable   { \n     let   id :   Int \n     var   name :   String ? \n     var   child :   MyUpdatableType \n\n     init ( id :   Int ,   name :   String ?,   child :   MyUpdatableType )   { \n         self . id   =   id \n         self . name   =   name \n         self . child   =   child \n     } \n\n     enum   Key :   String ,   CodingKey   { \n         case   id \n         case   name \n         case   child \n     } \n\n     func   update ( from   decoder :   Decoder )   throws   { \n         let   container   =   try   decoder . container ( keyedBy :   Key . self ) \n         name   =   try   container . decode ( String . self ,   forKey :   . name ) \n         child   =   try   container . update ( child ,   forKey :   . child ) \n     }  }  let   parent   =   Parent ( id :   2 ,   name :   Parent Old Name ,   child :   myObject )  // parent is a reference type and does not need reassignment after the update  try   someResponse . body . update ( parent )", 
            "title": "DecoderUpdatable"
        }, 
        {
            "location": "/model/#decodingfactory", 
            "text": "There are some classes that just can't be made to conform to  Decodable  for these, you can use a  DecodingFactory  to create an object from a  Decoder :  protocol   DecodingFactory   { \n     associatedtype   Model \n     func   create ( from   decoder :   Decoder )   throws   -   Model  }   struct   CLLocationFactory :   DecodingFactory   { \n     enum   Key :   String ,   CodingKey   { \n         case   latitude \n         case   longitude \n     } \n\n     func   create ( from   decoder :   Decoder )   throws   -   CLLocation   { \n         let   container   =   try   decoder . container ( keyedBy :   Key . self ) \n         let   latitude   =   try   container . decode ( Double . self ,   forKey :   . latitude ) \n         let   longitude   =   try   container . decode ( Double . self ,   forKey :   . longitude ) \n         return   CLLocation ( latitude :   latitude ,   longitude :   longitude ) \n     }  }   DecodingFactory  can be used with  HTTPBody s instead of a  Decodable  type:  let   location   =   someResponse . body . decode ( using :   CLLocationFactory ())", 
            "title": "DecodingFactory"
        }, 
        {
            "location": "/model/#manageddecodable", 
            "text": "CoreData objects are among those that can't be made  Decodable . For these there is another protocol:  ManagedDecodable  protocol   ManagedDecodable :   DecoderUpdatable   { \n     static   var   entityName :   String   {   get   } \n     static   var   matchKeys :   [ MatchKey ]?   {   get   } \n     static   func   createOrUpdate ( in   context :   NSManagedObjectContext ,   from   decoder :   Decoder )   throws   -   Self  }   The  createOrUpdate  function has a default implementation for all  NSManagedObject s which creates a new instance of the object in the  NSManagedObjectContext .  If you provide a  matchKeys  property, the default  createOrUpdate  implementation will update a matching object if it exists, and create a new one if it cannot find a match.  class   User :   NSManagedObject ,   ManagedDecodable   { \n     static   var   entityName :   String   =   User \n     static   var   matchKeys :   [ MatchKey ]?   =   [ \n         . key ( Key . id ) \n     ] \n\n     @NSManaged   var   id :   Int \n     @NSManaged   var   name :   String \n\n     enum   Key :   String ,   CodingKey   { \n         case   id \n         case   name \n     } \n\n     func   update ( from   decoder :   Decoder )   throws   { \n         let   container   =   try   decoder . container ( keyedBy :   Key . self ) \n         id   =   try   container . decode ( Int . self ,   forKey :   . id ) \n         name   =   try   container . decode ( String . self ,   forKey :   . name ) \n     }  }   ManagedDecodable  classes can be decoded using a  ManagedDecodingFactory :  let   factory   =   ManagedDecodingFactory User ( context :   myContext )  let   user   =   try   someResponse . body . decode ( using :   factory )", 
            "title": "ManagedDecodable"
        }, 
        {
            "location": "/model/#codingformats", 
            "text": "Forge has protocols for high-level decoders and encoders, like  JSONDecoder ,  PropertyListDecoder ,  JSONEncoder  and  PropertyListEncoder .  These are  DecodingFormat :  public   protocol   DecodingFormat   { \n     func   decoder ( for   data :   Data )   -   Decoder  }   and  EncodingFormat :  public   protocol   EncodingFormat   { \n     func   encode T :   Encodable ( _   value :   T )   throws   -   Data  }   HTTPBody s have  decodingFormat  and  encodingFormat  properties that correspond to these protocols.  The default values for these are  JSONDecoder()  and  JSONEncoder() , but requests executed through a  Gateway  may have these changed by the gateway.  These properties can be changed  someRequest . body . encodingFormat   =   PropertyListEncoder ()  let   value   =   try   someRequest . body . decode ( as :   MyType . self )   or you can pass a format explicitly to  HTTPBody 's  decode  and  encode  functions:  try   someRequest . body . encode ( myObject ,   with :   PropertyListEncoder ())  let   value   =   try   someRequest . body . decode ( as :   MyType . self ,   with :   PropertyListDecoder ())", 
            "title": "CodingFormats"
        }, 
        {
            "location": "/model/#decoding-promises", 
            "text": "Forge has conveniences for Decoding  Response  or  Request   Promise s that match the methods on  HTTPBody :  gateway \n   . request ( things ,   id ) \n   . execute () \n   . decode ( as :   MyType . self )   // Returns Promise MyType  gateway \n   . request ( things ,   id ) \n   . execute () \n   . decode ( as :   MyType . self ,   with :   PropertyListDecoder ())   // Returns Promise MyType  gateway \n   . request ( users ,   userID ) \n   . execute () \n   . decode ( using :   ManagedDecodingFactory User ( context :   myContext ))   // Returns Promise User   Requests executed through a  ManagedGateway  also have conveniences for  ManagedDecodable  objects, instead of needing a  ManagedDecodingFactory :  managedGateway \n   . request ( users ,   userID ) \n   . execute () \n   . decode ( managed :   User . self )   // Returns Promise User", 
            "title": "Decoding Promises"
        }, 
        {
            "location": "/middleware/", 
            "text": "Middleware", 
            "title": "Middleware"
        }, 
        {
            "location": "/middleware/#middleware", 
            "text": "", 
            "title": "Middleware"
        }, 
        {
            "location": "/documentation/", 
            "text": "Stub for actual documentation", 
            "title": "Documentation"
        }, 
        {
            "location": "/documentation/#stub-for-actual-documentation", 
            "text": "", 
            "title": "Stub for actual documentation"
        }
    ]
}